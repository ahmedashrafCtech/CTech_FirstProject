/*
 * ADC_program.c
 *
 *  Created on: Feb 27, 2023
 *      Author: Abdullah.Abomosallam
 */
/**
 * @author Abdullah Abomosallam
 *  this is the ADC body ofthe driver functions
 * @date :27/2/2023
 *
 */
#include"../../LIB/BIT_MATH.h"
#include"../../LIB/STD_TYPES.h"
#include"ADC_interface.h"
#include"ADC_pcfg.h"
#include"ADC_private.h"
/**
 * this function initialize the ADC peripheral
 * @param void
 * @return void
 *
 *
 */
void ADC_voidInit()
{

#if ADC_VREF == ADC_AREF
	WRITE_BIT(ADMUX,6,0);
	WRITE_BIT(ADMUX,7,0);
#elif ADC_VREF == ADC_AVCC
	WRITE_BIT(ADMUX,6,1);
		WRITE_BIT(ADMUX,7,0);
#elif ADC_VREF == ADC_INTERNAL_2
	WRITE_BIT(ADMUX,6,1);
		WRITE_BIT(ADMUX,7,1);
#endif


#if ADC_ADJUSTMENT ==ADC_RIGHT

		WRITE_BIT(ADMUX,5,0);

#elif ADC_ADJUSTMENT ==ADC_LEFT

		WRITE_BIT(ADMUX,5,1);
#endif


ADMUX&=ADC_MUXMASK ;

#if ADC_CHANNEL_MODE ==ADC_SINGLE_ENDED

#if ADC_CHANNEL_SELECTION ==ADC_SCHANNEL0
		ADMUX|=ADC_SCHANNEL0;
#elif ADC_CHANNEL_SELECTION ==ADC_SCHANNEL1
		ADMUX|=ADC_SCHANNEL1;
#elif ADC_CHANNEL_SELECTION ==ADC_SCHANNEL2
		ADMUX|=ADC_SCHANNEL2;
#elif ADC_CHANNEL_SELECTION ==ADC_SCHANNEL3
		ADMUX|=ADC_SCHANNEL3;
#elif ADC_CHANNEL_SELECTION ==ADC_SCHANNEL4
		ADMUX|=ADC_SCHANNEL4;
#elif ADC_CHANNEL_SELECTION ==ADC_SCHANNEL5
		ADMUX|=ADC_SCHANNEL5;
#elif ADC_CHANNEL_SELECTION ==ADC_SCHANNEL6
		ADMUX|=ADC_SCHANNEL6;
#elif ADC_CHANNEL_SELECTION ==ADC_SCHANNEL7
		ADMUX|=ADC_SCHANNEL7;
#endif
#endif
//the below values need to be  revised t 100%correct
#if ADC_CHANNEL_MODE ==ADC_DIFFRENTIAL
#if ADC_CHANNEL_SELECTION ==ADC_DCHANNEL0
		ADMUX|=ADC_DCHANNEL0;

#elif ADC_CHANNEL_SELECTION ==ADC_DCHANNEL1
		ADMUX|=ADC_DCHANNEL1;

#elif ADC_CHANNEL_SELECTION ==ADC_DCHANNEL2
		ADMUX|=ADC_DCHANNEL2;
#elif ADC_CHANNEL_SELECTION ==ADC_DCHANNEL3
		ADMUX|=ADC_DCHANNEL3;
#elif ADC_CHANNEL_SELECTION ==ADC_DCHANNEL4
		ADMUX|=ADC_DCHANNEL4;
#elif ADC_CHANNEL_SELECTION ==ADC_DCHANNEL5
		ADMUX|=ADC_DCHANNEL5;
#elif ADC_CHANNEL_SELECTION ==ADC_DCHANNEL6
		ADMUX|=ADC_DCHANNEL6;
#elif ADC_CHANNEL_SELECTION ==ADC_DCHANNEL7
		ADMUX|=ADC_DCHANNEL7;
#endif

#endif

		WRITE_BIT(ADCSRA,7,1);
#if ADC_USAGE==ADC_INTERRUPT
		WRITE_BIT(ADCCSRA,3,1);
#endif
		ADCSRA&=ADC_PREDCALER_MASK ;

#if ADC_PRESCALER ==ADC_PRESCALER_2
		        ADCSRA|=ADC_PRESCALER_2;

#elif ADC_PRESCALER ==ADC_PRESCALER_4
		        ADCSRA|=ADC_PRESCALER_4;

#elif ADC_PRESCALER ==ADC_PRESCALER_8
		        ADCSRA|=ADC_PRESCALER_8;
#elif ADC_PRESCALER ==ADC_PRESCALER_16
		        ADCSRA|=ADC_PRESCALER_16;
#elif ADC_PRESCALER ==ADC_PRESCALER_32
		        ADCSRA|=ADC_PRESCALER_32;
#elif ADC_PRESCALER ==ADC_PRESCALER_64
		        ADCSRA|=ADC_PRESCALER_64;
#elif ADC_PRESCALER ==ADC_PRESCALER_128
		        ADCSRA|=ADC_PRESCALER_128;
#endif

#if ADC_CONVERSION ==ADC_FREE_RUNNING
				 WRITE_BIT(SFIOR,5,0);
				 WRITE_BIT(SFIOR,6,0);
				 WRITE_BIT(SFIOR,7,0);
//The rest of auto trigeer sources to be comleted
#endif
}
//this function return the value of the analogue signal measured
u16 ADC_u8Getvalue()
{
u16 local_u8value=0;
#if ADC_ADJUSTMENT ==ADC_RIGHT
local_u8value=ADCL+(ADCH<<8);
return local_u8value;
#elif ADC_ADJUSTMENT ==ADC_LEFT
local_u8value=(ADCH<<2);
return local_u8value;
#endif
}
//this function starts the conversion
void ADC_voidStartConversion()
{


	WRITE_BIT(ADCSRA,6,1);

}
//this function RETURN the flag to check ADC status
u8 ADC_u8CheckFlag()
{




	return GET_BIT(ADCSRA,4);

}
